<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>åœ¨çº¿äº”å­æ£‹</title>
    <link rel="stylesheet" type="text/css" href="../common.css" />
    <link rel="stylesheet" href="./layout.css" />
    <link type="text/css" rel="styleSheet" href="../css/room.css" />
    <link type="text/css" rel="styleSheet" href="../css/index.css" />
  </head>

  <body onload="showTime()">
    <div class="head">
      <div class="index-image">
        <!-- TODO:logo -->
        <a href="index.html"
          ><img src="../image/logo.jpeg" alt="" width="100px" height="60px"
        /></a>
      </div>
      <!--æ»šåŠ¨æ¡-->
      <div class="time-bar">
        <marquee><p id="time"></p></marquee>
      </div>
      <!--ç™»é™†-->
      <div class="user">
        <a id="user-a" href="./login.html">ç™»é™†</a>
        <p id="user-p"></p>
      </div>
    </div>
    <!--å¯¼èˆªæ -->
    <div class="bar">
      <ul class="navigationBar">
        <li><a href="../index.html">ä¸»é¡µ</a></li>
        <li><a href="#news">æ–°é—»</a></li>
        <li><a href="../websocket_front/login.html">ä¸‹æ£‹</a></li>
        <li><a href="#about">å…³äº</a></li>
      </ul>
    </div>

    <div class="check">
      <input placeholder="è¾“å…¥ä½ çš„å†…å®¹" id="content" />
      <button id="send">å‘é€èŠå¤©æ¶ˆæ¯</button>
      <p id="ready_text">å‡†å¤‡ğŸ‘‰</p>
      <input type="checkbox" id="ready" />
      
      <div id="chat_room"></div>
    </div>
    <div id="result"></div>
    <div id="game" style="display: none; height: auto; width: auto">
      <canvas id="chess"></canvas>
      <div id="operate">
        <!-- <span id="goback" class="goback unable">æ‚”æ£‹</span>
              <span id="regret" class="regret unable">æ’¤é”€æ‚”æ£‹</span> -->
      </div>
    </div>
    <script type="text/javascript" src="../js/index-head.js"></script>
    <script>
      var ctt = document.querySelector("#content");
      var button = document.querySelector("#send");
      var div = document.querySelector("#chat_room");
      var isready = document.querySelector("#ready");
      var ready_text = document.querySelector("#ready_text");
      var game = document.querySelector("#game");
      var res = document.querySelector("#result");
      //è·å–urlä¸­"?"ç¬¦åçš„å­—ä¸²
      var keyword = GetRequest();
      function GetRequest() {
        var url = location.search;
        var theRequest = new Object();
        if (url.indexOf("?") != -1) {
          var str = url.substr(1);
          strs = str.split("&");
          for (var i = 0; i < strs.length; i++) {
            theRequest[strs[i].split("=")[0]] = decodeURIComponent(
              strs[i].split("=")[1]
            );
          }
        }
        return theRequest;
      }

      var socket = new WebSocket(
        "ws://8.142.81.74:8080/ws?room_id=" +
          keyword.room_id +
          "&uid=" +
          keyword.uid
      );
      socket.addEventListener("open", function () {
        div.innerHTML = "è¿æ¥æœåŠ¡å™¨æˆåŠŸ";
        var data = {
          user: keyword.uid,
          type: keyword.type,
          content: "",
          room_id: keyword.room_id,
        };
        console.log(data);
        socket.send(JSON.stringify(data));
      });

      //å‘æ¶ˆæ¯
      button.addEventListener("click", function () {
        var value = ctt.value;
        var data = {
          user: keyword.uid,
          type: "broad",
          content: value,
          room_id: keyword.room_id,
        };
        socket.send(JSON.stringify(data));
      });

      var NowPlayer = "1";
      //æ¥æ”¶æ¶ˆæ¯
      socket.addEventListener("message", function (ct) {
        console.log(ct);
        var cnt = JSON.parse(ct.data);
        if (cnt.type == "gameStart") {
          game.style = "display: block;";
          NowPlayer = cnt.user;
          if (cnt.user == "1") {
            result.innerHTML = "ä½ æ˜¯é»‘æ£‹";
          } else {
            result.innerHTML = "ä½ æ˜¯ç™½æ——";
          }
        } else {
          if (cnt.type == "game_over") {
            game.style = "display: none;";
            if (cnt.user == "1") {
              result.innerHTML = "é»‘æ£‹è·èƒœ";
            } else {
              result.innerHTML = "ç™½æ£‹è·èƒœ";
            }
          }
        }
        if (cnt.type == "message") {
          div.innerHTML =
            div.innerHTML + "<br/>" + cnt.user + " :  " + cnt.content;
        }
      });

      //æ–­å¼€æ—¶
      socket.addEventListener("close", function () {
        var data = {
          user: keyword.uid,
          type: "logout",
          content: "",
          room_id: keyword.room_id,
        };
        socket.send(JSON.stringify(data));
        div.innerHTML = "ä¸æœåŠ¡å™¨æ–­å¼€é“¾æ¥";
      });

      isready.onclick = function () {
        if (isready.checked == true) {
          var data = {
            user: keyword.uid,
            type: "ready",
            content: "",
            room_id: keyword.room_id,
          };
          socket.send(JSON.stringify(data));
          ready_text.innerHTML = "å–æ¶ˆå‡†å¤‡ğŸ‘‰";
        } else {
          var data = {
            user: keyword.uid,
            type: "unready",
            content: "",
            room_id: keyword.room_id,
          };
          socket.send(JSON.stringify(data));
          ready_text.innerHTML = "å‡†å¤‡ğŸ‘‰";
        }
      };
      class Gobang {
        constructor(options) {
          this.options = options;
          // è·å–æ£‹ç›˜
          this.chessboard = document.getElementById(options.canvas || "chess");
          // è·å–ç»“æœ
          this.result = document.getElementById("result");

          // åˆå§‹åŒ–
          this.init();
          // æ£‹ç›˜å…ƒç´ 
          this.lattice = {
            width: options.gobangStyle.padding,
            height: options.gobangStyle.padding,
          };
        }
        åˆå§‹åŒ–;
        init() {
          const { options } = this;
          // è§’è‰² ï¼Œ1é»‘è‰²æ£‹å­ 2ç™½è‰²æ£‹å­
          this.role = options.role || 1;
          // æ˜¯å¦å·²ç»åˆ†å‡ºäº†èƒœè´Ÿ
          this.win = false;
          // èµ°æ£‹çš„è®°å½•
          this.history = [];
          // å½“å‰æ­¥
          this.currentStep = 0;
          // ç»“æœæç¤ºä¿¡æ¯
          this.result.innerText = "";
          // ç”»å‡ºæ£‹ç›˜
          this.drawChessBoard();
          // è½å­
          this.listenDownChessman();
          //  åˆå§‹æ£‹ç›˜çŸ©é˜µ
          this.initChessboardMatrix();
        }

        // ç”»å‡ºæ£‹ç›˜
        drawChessBoard() {
          const { options } = this;
          const context = this.chessboard.getContext("2d");
          const { count, padding, borderColor } = options.gobangStyle;
          this.chessboard.width = this.chessboard.height = padding * count;
          context.strokeStyle = borderColor;
          context.lineWidth = 2;

          for (var i = 0; i < count; i++) {
            context.moveTo(15 + i * padding, 15);
            context.lineTo(15 + i * padding, count * padding - 15);
            context.stroke();
            context.moveTo(15, 15 + i * padding);
            context.lineTo(count * padding - 15, 15 + i * padding);
            context.stroke();
          }
        }
        // åˆå§‹æ£‹ç›˜çŸ©é˜µ
        initChessboardMatrix() {
          const { options } = this;
          const checkerboard = [];
          for (let x = 0; x < options.gobangStyle.count; x++) {
            checkerboard[x] = [];
            for (let y = 0; y < options.gobangStyle.count; y++) {
              checkerboard[x][y] = 0;
            }
          }
          this.checkerboard = checkerboard;
        }
        // åˆ¤æ–­ä¸‹è¾“èµ¢
        // checkReferee(x, y, role) {
        //     if ((x == undefined) || (y == undefined) || (role == undefined)) return;
        //     // è¿æ€çš„åˆ†æ•°
        //     let countContinuous = 0;
        //     const XContinuous = this.checkerboard.map(x => x[y]);
        //     const YContinuous = this.checkerboard[x];
        //     const S1Continuous = [];
        //     const S2Continuous = [];
        //     this.checkerboard.forEach((_y, i) => {
        //         // å·¦æ–œçº¿
        //         const S1Item = _y[y - (x - i)];
        //         if (S1Item !== undefined) {
        //             S1Continuous.push(S1Item);
        //         }
        //         // å³æ–œçº¿
        //         const S2Item = _y[y + (x - i)];
        //         if (S2Item !== undefined) {
        //             S2Continuous.push(S2Item);
        //         }
        //     });
        //     // å½“å‰è½æ£‹ç‚¹æ‰€åœ¨çš„Xè½´/Yè½´/äº¤å‰æ–œè½´ï¼Œåªè¦æœ‰èƒ½è¿èµ·æ¥çš„5ä¸ªå­çš„è§’è‰²å³æœ‰èƒœè€…
        //     [XContinuous, YContinuous, S1Continuous, S2Continuous].forEach(axis => {
        //         if (axis.some((x, i) => axis[i] !== 0 &&
        //             axis[i - 2] === axis[i - 1] &&
        //             axis[i - 1] === axis[i] &&
        //             axis[i] === axis[i + 1] &&
        //             axis[i + 1] === axis[i + 2])) {
        //             countContinuous++
        //         }
        //     });
        //     // å¦‚æœèµ¢äº†å°±ç»™å‡ºæç¤º
        //     if (countContinuous) {
        //         this.win = true;
        //         let msg = (role == 1 ? 'é»‘' : 'ç™½') + 'å­èƒœåˆ©âœŒï¸';
        //         // æç¤ºä¿¡æ¯
        //         this.result.innerText = msg;
        //         // ä¸å…è®¸å†æ“ä½œ
        //         this.chessboard.onclick = null;
        //     }

        // }
        // åˆ»ç”»æ£‹å­
        drawChessman(x, y, isBlack) {
          const context = this.chessboard.getContext("2d");
          context.beginPath();
          context.arc(15 + x * 30, 15 + y * 30, 13, 0, 2 * Math.PI); // ç”»åœ†
          context.closePath();
          //æ¸å˜
          var gradient = context.createRadialGradient(
            15 + x * 30 + 2,
            15 + y * 30 - 2,
            13,
            15 + x * 30 + 2,
            15 + y * 30 - 2,
            0
          );
          console.log(isBlack);
          if (isBlack == "1") {
            // é»‘å­
            gradient.addColorStop(0, "#0a0a0a");
            gradient.addColorStop(1, "#636766");
          } else {
            // ç™½å­
            gradient.addColorStop(0, "#d1d1d1");
            gradient.addColorStop(1, "#f9f9f9");
          }
          context.fillStyle = gradient;
          context.fill();
          // æ¯æ¬¡è½å­å®Œæˆåéƒ½è¦åˆ¤æ–­ä¸‹è¾“èµ¢
          // setTimeout(() => {
          //     this.checkReferee(x, y, isBlack ? 1 : 2);
          // }, 0);
        }
        // è½å­
        listenDownChessman() {
          //æ¥æ”¶æ¶ˆæ¯
          socket.addEventListener("message", function (ct) {
            var cnt = JSON.parse(ct.data);
            if (cnt.type == "moved") {
              var xy = cnt.content.split(",");
              var x = Number(xy[0]);
              var y = Number(xy[1]);

              // ç©ºçš„ä½ç½®æ‰å¯ä»¥è½å­
              if (
                gobangGame.checkerboard[x][y] != undefined &&
                Object.is(gobangGame.checkerboard[x][y], 0)
              ) {
                // è½å­åæ›´æ–°çŸ©é˜µ,åˆ‡æ¢è§’è‰²ï¼Œå¹¶ä¸”è®°å½•
                gobangGame.checkerboard[x][y] = gobangGame.role;
                // åˆ»ç”»æ£‹å­
                gobangGame.drawChessman(x, y, cnt.user);
                // è½å­å®Œä¹‹åæœ‰å¯èƒ½æ‚”æ£‹ä¹‹åè½å­ï¼Œè¿™ç§æƒ…å†µä¸‹åº”è¯¥é‡ç½®å†å²è®°å½•
                gobangGame.history.length = gobangGame.currentStep;
                gobangGame.history.push({
                  x,
                  y,
                  role: Number(cnt.user),
                });
                // ä¿å­˜åæ ‡ï¼Œåˆ‡æ¢è§’è‰²å’Œä¿å­˜å¿«ç…§
                gobangGame.currentStep++;
                //this.role = Object.is(this.role , 1) ? 2 : 1;
              }
            }
          });
          // console.log(bool)
          // if (bool) {

          // }
          // bool = false
          this.chessboard.onclick = (event) => {
            // è·å–æ£‹å­çš„ä½ç½®(x,y) => (0,1)
            var { offsetX: x, offsetY: y } = event;
            x = Math.round((x - 15) / this.lattice.width);
            y = Math.round((y - 15) / this.lattice.height);
            console.log(x, y);
            var data = {
              user: NowPlayer,
              type: "move",
              content: x + "," + y,
              room_id: keyword.room_id,
            };
            socket.send(JSON.stringify(data));
            socket.addEventListener("message", function (ct) {
              var cnt = JSON.parse(ct.data);
              if (cnt.type == "moved") {
                //     // ç©ºçš„ä½ç½®æ‰å¯ä»¥è½å­
                // if (gobangGame.checkerboard[x][y] !== undefined && Object.is(gobangGame.checkerboard[x][y], 0)) {
                //     // è½å­åæ›´æ–°çŸ©é˜µ,åˆ‡æ¢è§’è‰²ï¼Œå¹¶ä¸”è®°å½•
                //     gobangGame.checkerboard[x][y] = gobangGame.role;
                //     // åˆ»ç”»æ£‹å­
                //     gobangGame.drawChessman(x, y, Object.is(gobangGame.role, 1));
                //     // è½å­å®Œä¹‹åæœ‰å¯èƒ½æ‚”æ£‹ä¹‹åè½å­ï¼Œè¿™ç§æƒ…å†µä¸‹åº”è¯¥é‡ç½®å†å²è®°å½•
                //     gobangGame.history.length = gobangGame.currentStep;
                //     gobangGame.history.push({
                //         x,
                //         y,
                //         role: Number(cnt.user)
                //     });
                //     // ä¿å­˜åæ ‡ï¼Œåˆ‡æ¢è§’è‰²å’Œä¿å­˜å¿«ç…§
                //     gobangGame.currentStep++;
                //     //this.role = Object.is(this.role , 1) ? 2 : 1;
                // }
              }
            });
          };
        }
        // æ‚”æ£‹
        regretChess() {
          // æ‰¾åˆ°æœ€åä¸€æ¬¡è®°å½•ï¼Œå›æ»šåˆ°UIï¼Œæ›´æ–°çŸ©é˜µ
          if (this.history.length && !this.win) {
            const prev = this.history[this.currentStep - 1];
            if (prev) {
              const { x, y, role } = prev;
              // é”€æ¯æ£‹å­
              this.minusStep(x, y);
              this.checkerboard[prev.x][prev.y] = 0;
              this.currentStep--;
              this.role = Object.is(this.role, 1) ? 2 : 1;
            }
          }
        }
        // æ’¤é”€æ‚”æ£‹
        revokedRegretChess() {
          const next = this.history[this.currentStep];
          if (next) {
            this.drawChessman(next.x, next.y, next.role === 1);
            this.checkerboard[next.x][next.y] = next.role;
            this.currentStep++;
            this.role = Object.is(this.role, 1) ? 2 : 1;
          }
        }
        // é”€æ¯æ£‹å­
        minusStep(x, y) {
          let { options } = this;
          const { count } = options.gobangStyle;
          const context = this.chessboard.getContext("2d");
          context.clearRect(x * 30, y * 30, 30, 30);
          // é‡ç”»è¯¥åœ†å‘¨å›´çš„æ ¼å­,å¯¹è¾¹è§’çš„æ ¼å¼è¿›è¡Œç‰¹æ®Šçš„å¤„ç†
          if (x <= 0 && y <= 0) {
            this.fixchessboard(15, 15, 15, 30, 15, 15, 30, 15);
          } else if (x >= count - 1 && y <= 0) {
            this.fixchessboard(
              count * 30 - 15,
              15,
              count * 30 - 30,
              15,
              count * 30 - 15,
              15,
              count * 30 - 15,
              30
            );
          } else if (y >= count - 1 && x <= 0) {
            this.fixchessboard(
              15,
              count * 30 - 15,
              15,
              count * 30 - 30,
              15,
              count * 30 - 15,
              30,
              count * 30 - 15
            );
          } else if (x >= count - 1 && y >= count - 1) {
            this.fixchessboard(
              count * 30 - 15,
              count * 30 - 15,
              count * 30 - 30,
              count * 30 - 15,
              count * 30 - 15,
              count * 30 - 15,
              count * 30 - 15,
              count * 30 - 30
            );
          } else if (x <= 0 && y > 0 && y < count - 1) {
            this.fixchessboard(
              15,
              30 * y + 15,
              30,
              30 * y + 15,
              15,
              30 * y,
              15,
              30 * y + 30
            );
          } else if (y <= 0 && x > 0 && x < count - 1) {
            this.fixchessboard(
              x * 30 + 15,
              15,
              x * 30 + 15,
              30,
              x * 30,
              15,
              x * 30 + 30,
              15
            );
          } else if (x >= count - 1 && y > 0 && y < count - 1) {
            this.fixchessboard(
              count * 30 - 15,
              y * 30 + 15,
              count * 30 - 30,
              y * 30 + 15,
              count * 30 - 15,
              y * 30,
              count * 30 - 15,
              y * 30 + 30
            );
          } else if (y >= count - 1 && x > 0 && x < count - 1) {
            this.fixchessboard(
              x * 30 + 15,
              count * 30 - 15,
              x * 30 + 15,
              count * 30 - 30,
              x * 30,
              count * 30 - 15,
              x * 30 + 30,
              count * 30 - 15
            );
          } else {
            this.fixchessboard(
              15 + x * 30,
              y * 30,
              15 + x * 30,
              y * 30 + 30,
              x * 30,
              y * 30 + 15,
              (x + 1) * 30,
              y * 30 + 15
            );
          }
        }
        // ä¿®è¡¥åˆ é™¤åçš„æ£‹ç›˜
        fixchessboard(a, b, c, d, e, f, g, h) {
          const context = this.chessboard.getContext("2d");
          context.beginPath();
          context.lineWidth = 2;
          context.moveTo(a, b);
          context.lineTo(c, d);
          context.moveTo(e, f);
          context.lineTo(g, h);
          context.stroke();
        }
      }

      // å®ä¾‹åŒ–æ¸¸æˆ
      var gobangGame = new Gobang({
        canvas: "chess", // ç”»å¸ƒçš„id
        role: NowPlayer, // è§’è‰² 1é»‘è‰²æ£‹å­ 2ç™½è‰²æ£‹å­ ï¼Œè¿™é‡Œæ˜¯ç™½è‰²æ£‹å­å…ˆä¸‹
        gobangStyle: {
          // paddingä¸å…è®¸æ”¹å˜å“¦
          padding: 30, // è¾¹å’Œè¾¹ä¹‹é—´çš„è·ç¦» ,ä¸å¯ä¿®æ”¹ï¼Œè¿™é‡Œæ²¡è€ƒè™‘åˆ°è¾¹è·çš„é—®é¢˜
          count: 30, // æ­£æ–¹ä½“çš„è¾¹æ•°
          borderColor: "#bfbfbf", // æè¾¹çš„é¢œè‰²
        },
      });

      // æ‚”æ£‹
      let goback = document.getElementById("goback");
      goback.onclick = () => {
        gobangGame.regretChess();
      };

      // æ’¤é”€æ‚”æ£‹
      let regret = document.getElementById("regret");
      regret.onclick = () => {
        gobangGame.revokedRegretChess();
      };

      // é‡æ–°å¼€å§‹
      let restart = document.getElementById("restart");
      restart.onclick = () => {
        gobangGame.init();
      };
    </script>
  </body>
</html>
